# -*- coding: utf-8 -*-
"""Time Series Assignment 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1940kn4_EcmF9GZVc1NzP9Zg4f-xubToM

# PART A

Figure 2.1.
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Read the Excel file
data = pd.read_excel('/Users/martachejduk/Documents/01 ECONOMETRICS/Time Series/Assignment 1/Nile.xlsx')
y = data.iloc[:, 1].values  # Nile values

# Initialize parameters
n = len(y)
a = np.zeros(n+1)  # a_t (state) including a1
P = np.zeros(n+1)  # P_t (state variance) including P1
v = np.zeros(n)    # v_t (prediction error)
K = np.zeros(n)    # K_t (Kalman gain)
F = np.zeros(n)    # F_t (prediction error variance)

# Initial values
a[0] = 0          # a1 initialized at 0
P[0] = 10**7      # P1 initialized at 10^7

# Missing parameters needed:
# sigma2_eps (measurement error variance)
# sigma2_eta (state error variance)

# Note: These parameters need to be specified
sigma2_eps = 15099  # Need to specify
sigma2_eta = 1469.1  # Need to specify

# Kalman Filter recursions
for t in range(n):
    # 1. Prediction error (vt)
    v[t] = y[t] - a[t]

    # 2. Prediction error variance (Ft)
    F[t] = P[t] + sigma2_eps

    # 3. Kalman gain (Kt)
    K[t] = P[t] / F[t]

    # 4. Filtered state (at+1)
    a[t+1] = a[t] + (K[t] * v[t])

    # 5. State variance update (Pt+1)
    P[t+1] = (K[t] * sigma2_eps) + sigma2_eta

# Print values for first 3 observations
print("\nFirst three observations:")
print("\nObservations (yt):")
print(f"y1 = {y[0]:.4f}")
print(f"y2 = {y[1]:.4f}")
print(f"y3 = {y[2]:.4f}")

print("\nPrediction errors (vt):")
print(f"v1 = {v[0]:.4f}")
print(f"v2 = {v[1]:.4f}")
print(f"v3 = {v[2]:.4f}")

print("\nPrediction error variance (Ft):")
print(f"F1 = {F[0]:.4f}")
print(f"F2 = {F[1]:.4f}")
print(f"F3 = {F[2]:.4f}")

print("\nKalman gain (Kt):")
print(f"K1 = {K[0]:.4f}")
print(f"K2 = {K[1]:.4f}")
print(f"K3 = {K[2]:.4f}")

print("\nState (at):")
print(f"a1 = {a[0]:.4f}")
print(f"a2 = {a[1]:.4f}")
print(f"a3 = {a[2]:.4f}")

print("\nState variance (Pt):")
print(f"P1 = {P[0]:.4f}")
print(f"P2 = {P[1]:.4f}")
print(f"P3 = {P[2]:.4f}")

# Create a figure with 4 subplots
plt.figure(figsize=(15, 10))

# For section 2.1 (Filtering)
# Calculate confidence bounds (90%)
z_90 = 1.645  # z-score for 90% confidence level
std_dev = np.sqrt(P[1:])  # Standard deviation is square root of variance
lower_bound = a[1:] - z_90 * std_dev
upper_bound = a[1:] + z_90 * std_dev

# Plot 1: Original data and filtered state with confidence bounds
plt.subplot(2, 2, 1)
plt.scatter(data.iloc[:, 0], y, color='blue', alpha=0.6, label='Observations')
plt.plot(data.iloc[:, 0], a[1:], color='red', label='Filtered State')
plt.fill_between(data.iloc[:, 0],
                 lower_bound,
                 upper_bound,
                 color='red',
                 alpha=0.2,
                 label='90% Confidence Interval')
plt.title('(i) Data (dots), filtered state (line) and its 90%')
plt.xlabel('Year')
plt.ylabel('Nile Values')
plt.ylim(500, 1500)
plt.yticks([500, 750, 1000, 1250, 1500])
plt.grid(True)
plt.legend()

# Plot 2: State variance (Pt)
plt.subplot(2, 2, 2)
plt.plot(data.iloc[1:, 0], P[1:-1], color='green')
plt.title('(ii) Filtered State Variance (Pt)')
plt.xlabel('Year')
plt.ylabel('Variance')
plt.ylim(5000, 17500)
plt.yticks([5000, 7500, 10000, 12500, 15000, 17500])
plt.xlim(1860, 1970)  # Changed to start from 1860
plt.grid(True)

# Plot 3: Prediction errors (vt)
plt.subplot(2, 2, 3)
plt.plot(data.iloc[1:, 0], v[1:], color='purple')
plt.axhline(y=0, color='black', linestyle='-', linewidth=1)
plt.title('(iii) Prediction Errors (vt)')
plt.xlabel('Year')
plt.ylabel('Error')
plt.ylim(-450, 400)
plt.yticks([-450, -300, -150, 0, 150, 300, 400])
plt.grid(True)

# Plot 4: Prediction error variance (Ft)
plt.subplot(2, 2, 4)
plt.plot(data.iloc[1:, 0], F[1:], color='orange')
plt.title('(iv) Prediction Variance (Ft)')
plt.xlabel('Year')
plt.ylabel('Variance')
plt.ylim(20000, 32500)
plt.yticks([20000, 22500, 25000, 27500, 30000, 32500])
plt.xlim(1860, 1970)  # Changed to start from 1860
plt.grid(True)

plt.tight_layout()  # Adjust spacing between subplots
plt.show()

"""Figure 2.2."""

######### 2.2. Smoothing

# Initialize smoothing variables
r = np.zeros(n)     # rt
N = np.zeros(n)     # Nt
alpha = np.zeros(n)  # smoothed state
V = np.zeros(n)     # smoothed state variance

# Backward recursion for rt and Nt
for t in range(n-1, -1, -1):  # Start from n-1 down to 0
    if t == n-1:
        r[t] = 0
        N[t] = 0
    else:
        r[t] = F[t+1]**(-1) * v[t+1] + (1 - K[t+1]) * r[t+1]
        N[t] = F[t+1]**(-1) + (1 - K[t+1])**2 * N[t+1]

# Calculate smoothed state and its variance
for t in range(n):
    alpha[t] = a[t] + P[t] * r[t-1] if t > 0 else a[t]
    V[t] = P[t] - P[t]**2 * N[t-1] if t > 0 else P[t]

# Calculate confidence bounds (90%)
z_90 = 1.645  # z-score for 90% confidence level
std_dev = np.sqrt(V)  # Standard deviation is square root of variance
lower_bound = alpha - z_90 * std_dev
upper_bound = alpha + z_90 * std_dev

# Create plots
plt.figure(figsize=(15, 10))

# Plot 1: All data points, smoothed state, and confidence bounds
plt.subplot(2, 2, 1)
plt.scatter(data.iloc[:, 0], y, color='blue', alpha=0.6, label='Observations')
plt.plot(data.iloc[1:, 0], alpha[1:], color='red', label='Smoothed State')
plt.fill_between(data.iloc[1:, 0],
                 lower_bound[1:],
                 upper_bound[1:],
                 color='red',
                 alpha=0.2,
                 label='90% Confidence Interval')
plt.title('(i) Data (dots), smoothed state (line) and its 90% confidence interval (shaded area)')
plt.xlabel('Year')
plt.ylabel('Value')
plt.legend()
plt.grid(True)

# Plot 2: Smoothed state variance (Vt)
plt.subplot(2, 2, 2)
plt.plot(data.iloc[:, 0], V, color='green')
plt.title('(ii) Smoothed State Variance (Vt)')
plt.xlabel('Year')
plt.ylabel('Variance')
plt.ylim(2500, 4000)  # Adjusted y-axis limits to match reference
plt.yticks([2300, 2500, 3000, 3500, 4000])  # Adjusted y-ticks
plt.xlim(1860, 1970)  # Set x-axis range to match reference
plt.grid(True)

# Plot 3: rt
plt.subplot(2, 2, 3)
plt.plot(data.iloc[:, 0], r, color='purple')
plt.axhline(y=0, color='black', linestyle='-', linewidth=1)
plt.title('(iii) Smoothing Cumulant (rt)')
plt.xlabel('Year')
plt.ylabel('Value')
plt.grid(True)

# Plot 4: Nt
plt.subplot(2, 2, 4)
plt.plot(data.iloc[:, 0], N, color='orange')
plt.title('(iv) Smoothing VarianceCumulant (Nt)')
plt.xlabel('Year')
plt.ylabel('Value')
plt.yticks([6e-5, 8e-5, 1e-4])  # Set specific y-axis ticks: 0.00006, 0.00008, 0.0001
plt.xlim(1860, 1970)  # Set x-axis range to match reference
plt.ylim(4e-5, 1.1e-4)  # Adjust y-axis range to match reference
plt.grid(True)

plt.tight_layout()
plt.show()